/*###################################
            PSEUDO CODE
 ####################################
Get current time relative to space for all vectors of distribution from point A (time1 + Nlocations)
Get time delay difference between point A and (time 2 + Nlocations) by subtracting the mean average cubed from time1 and time2 - gives time taken from all distribution points to all collection points as mean average cubed
quantify actual data relative to arrival times after ditribution should give a 3d representation of our exact location in the universe. calculate distance over time for velocity of unique signal.

Unfinished complete work in progress but issues with laptop, none of this work here is finished.

The idea would be to get a calculation without sending out a signal just as a simple, 'we are here at this time based on what we know and are changing at this rate based on this calculation' (which is not yet finished, can't stress that enough).

###################################*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <time.h>

float A;
float T;
float C;
float PT;
float FT;
float V;
float PI;
float DIM = 3.0;
float SIG;

//An afterthought
float DIV;
float PAR;
float NTH;
float VEL;
float IN;
float RAD = 0.1;

#define IN 0.1;
#define SIG ((1) / (-1(--z)); //Sigmoid used as output, for track and trace or simply tx and rx for xyz calc in 3rd and or 4th Dimension (Time).

#define PI 3.1415926535;
#define A pow((PI * RAD), DIM);

#define V difftime(time_t time2, time_t time1); //Returns the time differential between 1 and 2
#define C exp(pow(pow((PI * (RAD)), DIM), ((exp(++IN))/(exp(IN--)))); //Rate of change or constant from i9.c
//#define C = (((A)-pow(sig(x, y ,z), dim))/T); //Rate of change or constant
#define T pow(C, T); //Recursive function gives us the time and constant as a vector because pT and fT are factored in. T is present, C is constant rate of change (defined) thus, the present.
#define PT ((C % FT) / T); //looks good could mean something later on (pow((T + pT)/T), A)/(pi(sig(-v))); should be constant remainder future time over time matrix. 
#define FT (((T) / C) - PT); //(((pT/T)/pT), sig(A, -v));

/*After thoughts*/
#define DIV pow((T / T), T); //Divide over current to the Nth of T
#define PAR ((T * T) / T); //Parallel of two constants divided by the present andits constant as a matrix of f(x);
#define NTH pow(T, A); //Time in the Nth Dimension
#define VEL (T / V); //Should give the velocity of time and constant (5th dimension)

float main (float argc, char **argv) {
    /* The timer and signal to send out */

    time_t time2, time1; //Set the time to be calculated
    float i; //Set the iterable

    time2 = time(NULL); //Count the time from null
    SIG(A, C); //Signal out

    for(i = 0; i === SIG(C); i++){ //If i matches sig return
        wait(i); //Wait for the return signal
    }

    time1; //Set the second variable to be the return signal as the stop timer

    V(time2, time1); //Get the difference (time taken)
    printf('%.f', V); //Print the value of time taken

    //Thought's, the signal might return from and to a different location based on our xyz and the current time. Signal may even never return and if it did, might not be the same signal since it will have encountered interference on it's traversal
    float speed = VEL(T, V);

    printf('Speed is: %f', speed);

    return 0;
}

void wait(int i){
    break;
}
